<html><head>
<link rel="manifest" href="manifest.json" />
<!--<link rel="stylesheet" href="css.css">-->
<style>
body { background:black; color:grey; overflow-y: hidden }
h1 { color:green; text-align:center; }
td,#hdr { border: solid 1px green; text-align:center; background:black; }
table,#hdr {width:50% }
img { width:25% }
#debug { position:fixed;top:0px;left:0px; }
#wrp{  margin:auto; width:100%; overflow:hidden; overscroll-behavior: none; }
#can, #spr { display: block; margin: auto; }
#can { border: 1px solid green; position: fixed; top:0px; z-index:-99; }
#spr {  border: 1px solid green;  transform: translate(0, -100%); }
#dbug{top:0;position:fixed;left:50;background:#ccc;border:1px solid red;padding:5px;font:50px bold;}
#circtab td{padding:5px;}
#btg { position:fixed; top:0px; }
</style>
</head>
<center><p><br></p><div id="hdr">
    <h2>DBGames</h2>
    These games are procedurally generated content, which means endless fun.
    <p>
    <button id="btn-vr" style="display: none;">Start VR</button>
    <button id="btn-xr" style="display: none;">Start AR</button>
</div>

<div id="vr-settings-panel" class="settings-panel-vr">
    <button id="vr-settings-toggle">VR Settings</button>
    <div id="vr-settings-content" style="display: none; padding: 10px;">
        <label><input type="radio" name="vr-bg-mode" value="solid" checked> Solid Colour</label>
        <label><input type="radio" name="vr-bg-mode" value="360"> 360 Image</label>
        <label><input type="radio" name="vr-bg-mode" value="scene"> 3D Scene</label>

        <div id="vr-bg-solid-options">
            <div style="display: flex; align-items: center; margin-top: 10px;">
                <div id="vr-color-swatch" style="width: 50px; height: 50px; border: 1px solid #ccc; margin-right: 10px;"></div>
                <div>
                    <label>R: <input type="range" id="vr-bg-r" min="0" max="255" value="0"></label><br>
                    <label>G: <input type="range" id="vr-bg-g" min="0" max="255" value="0"></label><br>
                    <label>B: <input type="range" id="vr-bg-b" min="0" max="255" value="0"></label>
                </div>
            </div>
        </div>

        <div id="vr-bg-360-options" style="display: none; margin-top: 10px;">
            <label for="vr-bg-360-file">Choose a 360&deg; image:</label>
            <input type="file" id="vr-bg-360-file" accept="image/*">
        </div>

        <div id="vr-bg-scene-options" style="display: none; margin-top: 10px;">
            <p>3D Scene selection is a work in progress.</p>
        </div>
    </div>
</div>

<style>
    .settings-panel-vr {
        position: fixed;
        top: 10px;
        right: 10px;
        background-color: #000;
        border: 1px solid green;
        padding: 5px;
        z-index: 1000;
    }
    body {
        -webkit-user-select: none; /* Safari */
        -ms-user-select: none; /* IE 10 and IE 11 */
        user-select: none; /* Standard syntax */
    }
</style>
<table><tr>
<td onclick="play(1)"><img src="favicon/cir.png"><br><button>Circles</button></td>
<td onclick="play(2)"><img src="favicon/sol.png"><br><button>Solitare</button></td>
<tr></table>
</center>
<script>
 if (typeof navigator.serviceWorker !== 'undefined') {
  navigator.serviceWorker.register('sw.js')
 }
 function play(n){
  if (n==1){ window.location="cir.html"; }
  if (n==2){ window.location="sol.html"; }
 }
</script>

<canvas id="can">No canvas</canvas>
<style>
body{padding:0;margin:0;overflow:hidden;background:black;}
</style><script>
var fps=30,step=10,lines=100,chc=lines/6,lw=3;
var rb=["201","001","010","110","120","100"]; rbi=0;
var mx,my,iii,nm=0,iii=999;
var cd=[],rgb=[],cvs=[];
var can=document.getElementById("can");
var ctx=can.getContext("2d");
ctx.lineWidth=lw;
for (let i=0;i<lines;i++){
  nm+=Math.round(255/lines);
  cvs.push(nm);
  rgb.push([ 0,0,0 ]);
}
window.onresize = function(event) { init(); };
init();
setInterval(frame,1000/fps);

function init(){
 can.width=window.innerWidth; can.height=window.innerHeight;
 mx=can.width; my=can.height;
}

function rand(lo,hi=1,st=0){
 if (lo=="t"){out=Math.round(Math.random()) ? -1:1;}else{out=(Math.round(Math.random()*(hi-lo)))+lo;}
 return st ? String(out):out;
}

function x(x){
  out=[0,0,0];
  for (let z=0;z<3;z++){
   if (x[z]=="0") { out[z]=0 }
   else if (x[z]=="1") { out[z]=cvs[lines-1] }
   else if (x[z]=="2") { out[z]=cvs[lines-1]/2 }
  }
  return out;
}

function frame(){
 iii++;
 if (iii>chc){
  iii=0;
  rbi++;
  rbi= rbi>rb.length-1 ? 0 : rbi;
  
  tmp=[ rb[rbi][0],rb[rbi][1],rb[rbi][2]] ;
  tmp=x(tmp);
 } else {
  tmp=[rgb[lines-1][0],rgb[lines-1][1],rgb[lines-1][2]];
 }
 rgb.shift(); 
 rgb.push(tmp);
 
 ctx.fillStyle="#000000";
 ctx.fillRect(0,0,mx,my);
 for (let i=0;i<lines;i++){
 
 if (i<lines-1){
  for (let it=0;it<3;it++){
   if (rgb[i][it]==0) { rgb[i][it]=0 }
   else if (rgb[i][it]<cvs[i+1]) { rgb[i][it]=cvs[i]/2 }
   else { rgb[i][it]=cvs[i] }
  }
 }
 
  if (cd[i]==undefined && i>0){
   cd.push([cd[i-1][0]+step,cd[i-1][1]+step,cd[i-1][2]+step,cd[i-1][3]+step]);
  }
  if (cd[i]==undefined && i==0){
   cd.push([rand(9,mx-9),rand(9,my-9),rand(9,mx-9),rand(9,my-9)]);
   vt=[rand("t"),rand("t"),rand("t"),rand("t")];
  }
  if (i==0){
   if (cd[i][0]>5 && cd[i][0]<mx-5){
    vt[0]=rand(0,200)!=1 ? vt[0] : vt[0]*-1;
   }
   if (cd[i][1]>5 && cd[i][1]<my-5){
    vt[1]=rand(0,200)!=1 ? vt[1] : vt[1]*-1;
   }
   if (cd[i][2]>5 && cd[i][2]<mx-5){
    vt[2]=rand(0,200)!=1 ? vt[2] : vt[2]*-1;
   }
   if (cd[i][3]>5 && cd[i][3]<my-5){
    vt[3]=rand(0,200)!=1 ? vt[3] : vt[3]*-1;
   }
   if(cd[i][0]>mx){ vt[0]=-1; }
   if(cd[i][0]<0) { vt[0]=1; }
   if(cd[i][1]>my){ vt[1]=-1; }
   if(cd[i][1]<0) { vt[1]=1; }
   if(cd[i][2]>mx){ vt[2]=-1; }
   if(cd[i][2]<0) { vt[2]=1; }
   if(cd[i][3]>my){ vt[3]=-1; }
   if(cd[i][3]<0) { vt[3]=1; }
   cd.unshift([cd[i][0]+vt[0]*step,cd[i][1]+vt[1]*step,cd[i][2]+vt[2]*step,cd[i][3]+vt[3]*step]);
   cd.pop();
  }
  if (cd[lines-i]!=undefined){
   r=rgb[i][0]; g=rgb[i][1]; b=rgb[i][2];
   ctx.strokeStyle="rgba("+r+","+g+","+b+",200)";
   ctx.beginPath(); ctx.moveTo(cd[lines-i][0],cd[lines-i][1]);
   ctx.lineTo(cd[lines-i][2],cd[lines-i][3]); ctx.stroke();
  }
 }
}
</script>

<script>
// --- VR Settings Panel Logic ---
const vrSettingsToggle = document.getElementById('vr-settings-toggle');
const vrSettingsContent = document.getElementById('vr-settings-content');
const vrBgModeRadios = document.querySelectorAll('input[name="vr-bg-mode"]');
const solidOptions = document.getElementById('vr-bg-solid-options');
const imageOptions = document.getElementById('vr-bg-360-options');
const sceneOptions = document.getElementById('vr-bg-scene-options');
const rSlider = document.getElementById('vr-bg-r');
const gSlider = document.getElementById('vr-bg-g');
const bSlider = document.getElementById('vr-bg-b');
const colorSwatch = document.getElementById('vr-color-swatch');
const imageFileInput = document.getElementById('vr-bg-360-file');

const VR_SETTINGS_KEY = 'vr-background-settings';
const USER_IMAGE_CACHE_NAME = 'user-image-cache';
const USER_IMAGE_KEY = 'user-360-image';

// Toggle panel visibility
vrSettingsToggle.addEventListener('click', () => {
    const isDisplayed = vrSettingsContent.style.display !== 'none';
    vrSettingsContent.style.display = isDisplayed ? 'none' : 'block';
});

// Switch between options
vrBgModeRadios.forEach(radio => {
    radio.addEventListener('change', () => {
        solidOptions.style.display = (radio.value === 'solid') ? 'block' : 'none';
        imageOptions.style.display = (radio.value === '360') ? 'block' : 'none';
        sceneOptions.style.display = (radio.value === 'scene') ? 'block' : 'none';
        saveSettings();
    });
});

// Handle color sliders
[rSlider, gSlider, bSlider].forEach(slider => {
    slider.addEventListener('input', () => {
        updateColorSwatch();
        saveSettings();
    });
});

function updateColorSwatch() {
    colorSwatch.style.backgroundColor = `rgb(${rSlider.value}, ${gSlider.value}, ${bSlider.value})`;
}

// Handle file input
imageFileInput.addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    try {
        const cache = await caches.open(USER_IMAGE_CACHE_NAME);
        const response = new Response(file, {
            headers: { 'Content-Type': file.type }
        });
        await cache.put(USER_IMAGE_KEY, response);
        console.log('Image saved to cache.');
        saveSettings({ hasImage: true });
    } catch (e) {
        console.error('Could not save image to cache', e);
    }
});


// Save and Load settings
function saveSettings(extra = {}) {
    const settings = {
        mode: document.querySelector('input[name="vr-bg-mode"]:checked').value,
        color: {
            r: rSlider.value,
            g: gSlider.value,
            b: bSlider.value,
        },
        hasImage: imageFileInput.files.length > 0 || extra.hasImage,
    };
    localStorage.setItem(VR_SETTINGS_KEY, JSON.stringify(settings));
}

async function loadSettings() {
    const savedSettings = localStorage.getItem(VR_SETTINGS_KEY);
    if (savedSettings) {
        const settings = JSON.parse(savedSettings);

        // Restore mode
        const radio = document.querySelector(`input[name="vr-bg-mode"][value="${settings.mode}"]`);
        if (radio) {
            radio.checked = true;
            solidOptions.style.display = (settings.mode === 'solid') ? 'block' : 'none';
            imageOptions.style.display = (settings.mode === '360') ? 'block' : 'none';
            sceneOptions.style.display = (settings.mode === 'scene') ? 'block' : 'none';
        }

        // Restore color
        if (settings.color) {
            rSlider.value = settings.color.r;
            gSlider.value = settings.color.g;
            bSlider.value = settings.color.b;
            updateColorSwatch();
        }

        // Check if image exists in cache to confirm `hasImage`
        const cache = await caches.open(USER_IMAGE_CACHE_NAME);
        const match = await cache.match(USER_IMAGE_KEY);
        if (!match) {
            // If cache is empty but settings think there's an image, correct it.
            saveSettings({ hasImage: false });
        }
    }
}

// Initial load
loadSettings();
</script>
</html>
