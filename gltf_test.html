<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>glTF Drawing Test (Programmatic Data)</title>
    <style>
        body { margin: 0; }
        canvas { display: block; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="glcanvas"></canvas>

    <script src="gl-matrix.min.js"></script>

    <script>
        async function main() {
            const canvas = document.querySelector("#glcanvas");
            // Set canvas drawing buffer size to match its display size.
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            const gl = canvas.getContext("webgl");
            if (!gl) {
                alert("Unable to initialize WebGL. Your browser or machine may not support it.");
                return;
            }

            // --- Shader Program ---
            const programInfo = setupSolidColorShaderProgram(gl);

            // --- Create Test Model Programmatically ---
            // This test bypasses file loading to directly test the drawing logic,
            // specifically the case where a model has no normal data.
            const vertices = new Float32Array([
                 0.0,  0.5, 0.0,
                -0.5, -0.5, 0.0,
                 0.5, -0.5, 0.0
            ]);
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const renderData = {
                models: [{
                    buffers: {
                        position: positionBuffer,
                        normal: null, // Explicitly testing the null normal case
                        indices: null
                    },
                    vertexCount: 3,
                    indexType: null,
                    color: [1.0, 0.5, 0.2, 1.0], // Orange triangle
                    modelMatrix: glMatrix.mat4.create()
                }]
            };

            // --- Render Loop ---
            function render(now) {
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                gl.clearColor(0.1, 0.1, 0.1, 1.0);
                gl.clearDepth(1.0);
                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LEQUAL);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                const fieldOfView = 45 * Math.PI / 180;
                const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
                const projectionMatrix = glMatrix.mat4.perspective(fieldOfView, aspect, 0.1, 100.0);

                const viewMatrix = glMatrix.mat4.create();
                glMatrix.mat4.lookAt(viewMatrix, [0, 0, 3], [0, 0, 0], [0, 1, 0]);

                const mockView = {
                    projectionMatrix: projectionMatrix,
                    transform: { inverse: { matrix: viewMatrix } }
                };

                drawGltfScene(gl, programInfo, renderData, mockView);

                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }

        // --- Helper functions (Shader setup, etc.) ---

        function setupSolidColorShaderProgram(gl) {
            const vsSource = `
              attribute vec4 aVertexPosition;
              attribute vec3 aVertexNormal;
              uniform mat4 uModelViewMatrix;
              uniform mat4 uProjectionMatrix;
              uniform mat4 uNormalMatrix;
              varying highp vec3 vLighting;
              void main(void) {
                // Hardcode position to Normalized Device Coordinates to bypass matrices.
                gl_Position = vec4(aVertexPosition.xy, 0.0, 1.0);
                // Hardcode lighting to a dummy value since we are not calculating it.
                vLighting = vec3(1.0);
              }`;
            const fsSource = `
              precision mediump float;
              uniform vec4 uColor;
              varying highp vec3 vLighting;
              void main(void) {
                // Hardcode to magenta for debugging the geometry pipeline
                gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
              }`;
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
            return {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                    vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'),
                },
                uniformLocations: {
                    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                    modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                    normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),
                    color: gl.getUniformLocation(shaderProgram, 'uColor'),
                },
            };
        }

        function initShaderProgram(gl, vsSource, fsSource) {
          const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
          const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
          const shaderProgram = gl.createProgram();
          gl.attachShader(shaderProgram, vertexShader);
          gl.attachShader(shaderProgram, fragmentShader);
          gl.linkProgram(shaderProgram);
          if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.error("Unable to initialize the shader program: " + gl.getProgramInfoLog(shaderProgram));
            return null;
          }
          return shaderProgram;
        }

        function loadShader(gl, type, source) {
          const shader = gl.createShader(type);
          gl.shaderSource(shader, source);
          gl.compileShader(shader);
          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
          }
          return shader;
        }

        // --- Drawing functions to be tested ---

        function drawGltfScene(gl, programInfo, renderData, view) {
            for (const model of renderData.models) {
                drawGltfMesh(gl, programInfo, model, view);
            }
        }

        function drawGltfMesh(gl, programInfo, model, view) {
            gl.useProgram(programInfo.program);

            const finalModelViewMatrix = glMatrix.mat4.multiply(glMatrix.mat4.create(), view.transform.inverse.matrix, model.modelMatrix);
            const normalMatrix = glMatrix.mat4.create();
            glMatrix.mat4.invert(normalMatrix, finalModelViewMatrix);
            glMatrix.mat4.transpose(normalMatrix, normalMatrix);

            gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, view.projectionMatrix);
            gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, finalModelViewMatrix);
            gl.uniformMatrix4fv(programInfo.uniformLocations.normalMatrix, false, normalMatrix);
            gl.uniform4fv(programInfo.uniformLocations.color, model.color);

            gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
            gl.bindBuffer(gl.ARRAY_BUFFER, model.buffers.position);
            gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 3, gl.FLOAT, false, 0, 0);

            // This is the logic under test:
            if (model.buffers.normal) {
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexNormal);
                gl.bindBuffer(gl.ARRAY_BUFFER, model.buffers.normal);
                gl.vertexAttribPointer(programInfo.attribLocations.vertexNormal, 3, gl.FLOAT, false, 0, 0);
            } else {
                gl.disableVertexAttribArray(programInfo.attribLocations.vertexNormal);
                gl.vertexAttrib3f(programInfo.attribLocations.vertexNormal, 0.0, 0.0, 1.0); // Fallback
            }

            if (model.buffers.indices) {
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.buffers.indices);
                gl.drawElements(gl.TRIANGLES, model.vertexCount, model.indexType, 0);
            } else {
                gl.drawArrays(gl.TRIANGLES, 0, model.vertexCount);
            }
        }

        main();
    </script>
</body>
</html>
